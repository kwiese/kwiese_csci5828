1. An essential difficulty is one that has to do with the larger inherent issues that come with software engineering. In my few years as a programmer, I have experienced essential difficulties a few times. One instance was at my first internship where, due to security reasons, they had a very complicated structure of how their data was stored and should be accessed, the main issue that came along with this was that only one person really knew what was going on with it and that person was out for the summer, which in turn, caused a loss of knowledge when I came in and had to work with the data. The reason I believe this to be an essential difficulty is that since the system they set up to store and retrieve data was so complicated, they couldn’t come up with good enough documentation to explain everything involved or spend the time to train multiple people on it, and as a result, there was a significant loss of knowledge when the person who knew and worked with the system was out for a few months. Another example would be if a programmer is working on a project that is supposed to only work with HR related tasks, then a manager comes in and asks the programmer to adapt to allow for the system to conform with what DevOps needs, this is something that the programmer couldn’t see coming and is, therefore, an essential difficulty. Both of these examples represent essential difficulties because they are problems that tend to come along with software engineering no matter what production steps you may try to take.
2. An accidental difficulty is one that has less to do with the inherent issues that come with software engineering but rather more to do with the issues that arise in the production of software. One personal experience with an accidental difficulty came up with my internship this past summer where we tried using a thing called a “tribe node” in elastic search, which allowed for a shared front end node to multiple users, but at the same time was harder to set up and could cause outages to multiple users for every update needed for that node to work. So, in order to fix this issue, we went with a solution that didn’t use a tribe node but rather just gave a separate front end node to each user; however, with this fix there was a higher resource cost. I believe this to be an accidental difficulty because the problem arose with the nature of how the tribe node worked rather than the nature of how software engineering works. Another example would be if a programmer decided to use a SQL database that didn’t end up adapting to how the system needs to work on a large scale, they can simple switch to Hadoop to store the data instead. 
3. Brooks goes into 4 different types of essential difficulties: complexity, conformity, changeability, and invisibility.
  1. Complexity has to do with the fact that many of the large scale software programs out in the world today are complex; they connect and interact with many different and individual sections. As these programs continue to get larger, the complexity continues to get larger, which in turn makes it harder to understand, refactor, and maintain the code. For instance, the animation software Maya has a hundreds of features that work in sync with each other and can have many states interacting with each other at the same time. If there was a bug in one small section of the Maya code, it could very easily propagate do multiple other features causing a cascade of issues and errors. However, due to the nature of how animation software needs to work, this complexity cannot be abstracted away from the application domain. 
  2. Conformity has to do with the fact that requirements can be changed or added over the course of an applications life. For instance, if an application that was used by itself in a specific part of a company needed to be added to a companywide system, it may need to conform with that system even if it was never designed to be integrated with it. The main point Brooks is trying to make about conformity is the fact that a programmer can’t see into the future, and as a result, cannot plan for specific changes that can occur over an applications life time. On example of this would be the conversion of programs and services to move from on premise locations to the cloud. For instance, a company might have web applications running on their on premise servers which connect to on premise databases; however, when moving to the cloud, these services need to be packaged and altered in order to provide for secure connections to the remaining on premise services.
  3. Changeability has to do with the fact that over the course of an applications life, the functionality and features need to adapt and change fairly consistently. These changes are usually difficult since they need to happen quickly but also need to not break the application when the changes are complete. This is similar to conformity in that it is nearly impossible to plan what changes will need to be made from the start. For instance, when Samsung released their first phone with a finger print scanner, there ended up being a security bug. Samsung then had to quickly change how their code worked and push an update out that fixed the issue. 
  4. Invisibility has to do with the fact that software isn’t a tangible item that we can physically touch and manipulate, but rather is more of an abstract concept that can be difficult to visually represent. For instance, even though we have ways of describing a program, like UML, we can’t really fit every single detail that happens in the code onto a diagram that contains just 13 symbols. One other issue with trying to represent applications visually is the fact that they are “brittle” in that as soon as the code changes, which happens often, the diagrams become out of date and need to be re done. For instance, there are activity diagrams, sequence diagrams, and UML diagrams but as soon as a new class is added to a piece of code, all of the diagrams just mentioned have to be altered in order to accurately represent the code.
4. What brooks means by a “silver bullet” is a single process or methodology that increases the productivity of engineering a piece of software by 10 fold. Brooks argues that this is not possible because of a few key points. One is that most of the progress that we’ve made in increasing software engineering productivity has only addressed the accidental difficulties and not the essential, where most of the inefficiencies come from. Another point that Brooks makes is that even though plenty of people out in the world claim that their method is the “silver bullet” none have actually solved every problem and increased productivity by a factor of 10. Brooks also points out that every solution so far may solve one problem, but in turn, will introduce a different problem. By combining these three points, Brooks makes a compelling point that in the past 40ish years of software engineering, most of the methodologies in existence only focus on a section of the difficulties that come with software engineering and since the majority of difficulties are essential difficulties, there most likely will not, if ever, be a “silver bullet” that increases productivity by 10 fold. However, just because there is no “silver bullet” out there does not mean that we still shouldn’t try to decrease the essential as well as the accidental difficulties that come with software engineering.
5. In class, a chemist was described as someone who does more of the theoretical and initial discovery of some process or compound whereas the chemical engineer takes what the chemist discovered and finds a way to make it viable in scale as well as how to bring it fully into production. This analogy carries over to computer science and engineering in that there is a lot of theory and small scale projects that are done in the field, however many of these haven’t been brought into existence or scaled up. For instance, some researchers discovered that theoretically it is possible to bring the amount of atoms needed for storage of a Bit down from 1 million to 12; however, this idea has yet to be produced in a way that can be scaled and will require a lot of time and energy spent by engineers in order to make it into reality.
6.	
  * _Abstractions_: Abstractions are segments of code that the developer doesn’t necessarily needs to understand the specifics of how everything works “under the hood” but uses or creates in order to break down the problem into something understandable. One of the advantages to abstractions is that it is much easier to build on top of an abstraction vs doing everything by hand. For instance, let’s say a developer wants to make a program that looks at the twitter trends of the 2016 election, the developer could make his own function that scrapes data directly off the twitter page, which would take a lot of time and energy to do correctly, or he could use the abstraction that twitter offers in the form of its API. Along with making the development of this application easier, the Twitter API allowed for the complexity of the code to decrease as well as providing the resources the engineer needs. 
  * _Conversations_: Conversations are a way to communicate between everyone and everything that is crucial to the project and are important for many reasons. Communication between the engineer and user allows for the application to work in the way that the user actually needs it to work. Conversations between developers allow for the application to have a better overall design as well as understanding about how the code works as a whole. Conversations between the code and test cases allows for the developer to understand where and why certain aspects of the code might be broken. Conversations between the developer and documentation will allow for cleaner and better designed code. One example of communication between the developer and documentation could be that a due to a new requirement by his boss, he has to write an API in GOLANG when he’s never used that language before. By having documentation easily available, the creators of GOLANG have made it easier for the developer to understand how the language work and what tools he needs for his API to work correctly.
  * _Specification_: Specifications are ways the developer captures everything about how the application works and should work. Specifications are important to the software engineering process because they allow for other developers to understand the process that an application has taken and what’s going on in it. Not only do they help others understand what’s going on, but also allow for a base line of what the developer needs to add to the application. For instance, when starting on a new project, your boss may come to you and give you a list of functionality he wants done close to certain checkpoints in the upcoming sprint. This gives the developer an idea as to what functionalities they need to narrow down as well as how long the implementation of those functionalities are expected to take.
  * _Translation_: Translation is the ability of a developer to continually adapt the application to fit its changes and needs over time. Translation is important because no matter the application, over time its specifications, code, design, structures, etc. change from what they were originally. As a result of these changes, the ability to translate every aspect of an application is crucial to a developer. For instance, if a company wants to change the service where they store their logs on from Sumo Logic to AWS, the developer needs to understand how the AWS abstractions (such as APIs) work and how the existing code base needs to be translated in order to reflect this desired change.
  * _Iteration_: Iteration is the coding style to code and test each incremental step of an application. The reason it’s a good idea to use iteration is that it helps catch mistakes quick and early while they’re easy to fix rather than waiting for a large section of code to be done and going back and trying to find everywhere that the code breaks. For instance, on any school or work related project, I always try to start compiling or running my program with a single print statement to be sure that I have everything set up correctly, then I move on to adding one small piece of functionality, testing it, then moving on to the next piece until the entire program is done. By doing this, I can solve bugs as they come up instead of finishing the entire code base and trying to back track to where the bug exists and trying to fix it without breaking the rest of the code.
